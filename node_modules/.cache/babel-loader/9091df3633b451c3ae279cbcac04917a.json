{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleMountainRange = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\n\nconst Base_1 = __importDefault(require(\"./Base\")); // @credit: https://github.com/wanseob/solidity-mmr\n\n/**\n * @desc The index of this MMR implementation starts from 1 not 0.\n */\n\n\nclass MerkleMountainRange extends Base_1.default {\n  constructor() {\n    let hashFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : sha256_1.default;\n    let leaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let hashLeafFn = arguments.length > 2 ? arguments[2] : undefined;\n    let peakBaggingFn = arguments.length > 3 ? arguments[3] : undefined;\n    let hashBranchFn = arguments.length > 4 ? arguments[4] : undefined;\n    super();\n    this.root = buffer_1.Buffer.alloc(0);\n    this.size = 0;\n    this.width = 0;\n    this.hashes = {};\n    this.data = {};\n    leaves = leaves.map(this.bufferify);\n    this.hashFn = this.bufferifyFn(hashFn);\n    this.hashLeafFn = hashLeafFn;\n    this.peakBaggingFn = peakBaggingFn;\n    this.hashBranchFn = hashBranchFn;\n\n    for (const leaf of leaves) {\n      this.append(leaf);\n    }\n  }\n  /**\n   * @desc This only stores the hashed value of the leaf.\n   * If you need to retrieve the detail data later, use a map to store them.\n   */\n\n\n  append(data) {\n    data = this.bufferify(data);\n    const dataHash = this.hashFn(data);\n    const dataHashHex = this.bufferToHex(dataHash);\n\n    if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {\n      this.data[dataHashHex] = data;\n    }\n\n    const leaf = this.hashLeaf(this.size + 1, dataHash);\n    this.hashes[this.size + 1] = leaf;\n    this.width += 1; // find peaks for enlarged tree\n\n    const peakIndexes = this.getPeakIndexes(this.width); // the right most peak's value is the new size of the updated tree\n\n    this.size = this.getSize(this.width); // starting from the left-most peak, get all peak hashes\n\n    const peaks = [];\n\n    for (let i = 0; i < peakIndexes.length; i++) {\n      peaks[i] = this._getOrCreateNode(peakIndexes[i]);\n    } // update the tree root hash\n\n\n    this.root = this.peakBagging(this.width, peaks);\n  }\n  /**\n   * @desc It returns the hash of a leaf node with hash(M | DATA )\n   *       M is the index of the node.\n   */\n\n\n  hashLeaf(index, dataHash) {\n    dataHash = this.bufferify(dataHash);\n\n    if (this.hashLeafFn) {\n      return this.bufferify(this.hashLeafFn(index, dataHash));\n    }\n\n    return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), dataHash]));\n  }\n  /**\n   * @desc It returns the hash a parent node with hash(M | Left child | Right child)\n   *       M is the index of the node.\n   */\n\n\n  hashBranch(index, left, right) {\n    if (this.hashBranchFn) {\n      return this.bufferify(this.hashBranchFn(index, left, right));\n    }\n\n    return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));\n  }\n\n  getPeaks() {\n    const peakIndexes = this.getPeakIndexes(this.width);\n    const peaks = [];\n\n    for (let i = 0; i < peakIndexes.length; i++) {\n      peaks[i] = this.hashes[peakIndexes[i]];\n    }\n\n    return peaks;\n  }\n\n  getLeafIndex(width) {\n    if (width % 2 === 1) {\n      return this.getSize(width);\n    }\n\n    return this.getSize(width - 1) + 1;\n  }\n  /**\n   * @desc It returns all peaks of the smallest merkle mountain range tree which includes\n   *       the given index(size).\n   */\n\n\n  getPeakIndexes(width) {\n    const numPeaks = this.numOfPeaks(width);\n    const peakIndexes = [];\n    let count = 0;\n    let size = 0;\n\n    for (let i = 255; i > 0; i--) {\n      if ((width & 1 << i - 1) !== 0) {\n        // peak exists\n        size = size + (1 << i) - 1;\n        peakIndexes[count++] = size;\n\n        if (peakIndexes.length >= numPeaks) {\n          break;\n        }\n      }\n    }\n\n    if (count !== peakIndexes.length) {\n      throw new Error('invalid bit calculation');\n    }\n\n    return peakIndexes;\n  }\n\n  numOfPeaks(width) {\n    let bits = width;\n    let num = 0;\n\n    while (bits > 0) {\n      if (bits % 2 === 1) {\n        num++;\n      }\n\n      bits = bits >> 1;\n    }\n\n    return num;\n  }\n\n  peakBagging(width, peaks) {\n    const size = this.getSize(width);\n\n    if (this.numOfPeaks(width) !== peaks.length) {\n      throw new Error('received invalid number of peaks');\n    }\n\n    if (width === 0 && !peaks.length) {\n      return buffer_1.Buffer.alloc(0);\n    }\n\n    if (this.peakBaggingFn) {\n      return this.bufferify(this.peakBaggingFn(size, peaks));\n    }\n\n    return this.hashFn(buffer_1.Buffer.concat([this.bufferify(size), ...peaks.map(this.bufferify)]));\n  }\n  /**\n   * @desc It returns the size of the tree.\n   */\n\n\n  getSize(width) {\n    return (width << 1) - this.numOfPeaks(width);\n  }\n  /**\n   * @desc It returns the root value of the tree.\n   */\n\n\n  getRoot() {\n    return this.root;\n  }\n\n  getHexRoot() {\n    return this.bufferToHex(this.getRoot());\n  }\n  /**\n   * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.\n   */\n\n\n  getNode(index) {\n    return this.hashes[index];\n  }\n  /**\n   * @desc It returns the height of the highest peak.\n   */\n\n\n  mountainHeight(size) {\n    let height = 1;\n\n    while (1 << height <= size + height) {\n      height++;\n    }\n\n    return height - 1;\n  }\n  /**\n   * @desc It returns the height of the index.\n   */\n\n\n  heightAt(index) {\n    let reducedIndex = index;\n    let peakIndex = 0;\n    let height = 0; // if an index has a left mountain then subtract the mountain\n\n    while (reducedIndex > peakIndex) {\n      reducedIndex -= (1 << height) - 1;\n      height = this.mountainHeight(reducedIndex);\n      peakIndex = (1 << height) - 1;\n    } // index is on the right slope\n\n\n    return height - (peakIndex - reducedIndex);\n  }\n  /**\n   * @desc It returns whether the index is the leaf node or not\n   */\n\n\n  isLeaf(index) {\n    return this.heightAt(index) === 1;\n  }\n  /**\n   * @desc It returns the children when it is a parent node.\n   */\n\n\n  getChildren(index) {\n    const left = index - (1 << this.heightAt(index) - 1);\n    const right = index - 1;\n\n    if (left === right) {\n      throw new Error('not a parent');\n    }\n\n    return [left, right];\n  }\n  /**\n   * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.\n   */\n\n\n  getMerkleProof(index) {\n    if (index > this.size) {\n      throw new Error('out of range');\n    }\n\n    if (!this.isLeaf(index)) {\n      throw new Error('not a leaf');\n    }\n\n    const root = this.root;\n    const width = this.width; // find all peaks for bagging\n\n    const peaks = this.getPeakIndexes(this.width);\n    const peakBagging = [];\n    let cursor = 0;\n\n    for (let i = 0; i < peaks.length; i++) {\n      // collect the hash of all peaks\n      peakBagging[i] = this.hashes[peaks[i]]; // find the peak which includes the target index\n\n      if (peaks[i] >= index && cursor === 0) {\n        cursor = peaks[i];\n      }\n    }\n\n    let left = 0;\n    let right = 0; // get hashes of the siblings in the mountain which the index belgons to.\n    // it moves the cursor from the summit of the mountain down to the target index\n\n    let height = this.heightAt(cursor);\n    const siblings = [];\n\n    while (cursor !== index) {\n      height--;\n      [left, right] = this.getChildren(cursor); // move the cursor down to the left size or right size\n\n      cursor = index <= left ? left : right; // remaining node is the sibling\n\n      siblings[height - 1] = this.hashes[index <= left ? right : left];\n    }\n\n    return {\n      root,\n      width,\n      peakBagging,\n      siblings\n    };\n  }\n  /**\n   * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n   */\n\n\n  verify(root, width, index, value, peaks, siblings) {\n    value = this.bufferify(value);\n    const size = this.getSize(width);\n\n    if (size < index) {\n      throw new Error('index is out of range');\n    } // check the root equals the peak bagging hash\n\n\n    if (!root.equals(this.peakBagging(width, peaks))) {\n      throw new Error('invalid root hash from the peaks');\n    } // find the mountain where the target index belongs to\n\n\n    let cursor = 0;\n    let targetPeak;\n    const peakIndexes = this.getPeakIndexes(width);\n\n    for (let i = 0; i < peakIndexes.length; i++) {\n      if (peakIndexes[i] >= index) {\n        targetPeak = peaks[i];\n        cursor = peakIndexes[i];\n        break;\n      }\n    }\n\n    if (!targetPeak) {\n      throw new Error('target not found');\n    } // find the path climbing down\n\n\n    let height = siblings.length + 1;\n    const path = new Array(height);\n    let left = 0;\n    let right = 0;\n\n    while (height > 0) {\n      // record the current cursor and climb down\n      path[--height] = cursor;\n\n      if (cursor === index) {\n        // on the leaf node. Stop climbing down\n        break;\n      } else {\n        // on the parent node. Go left or right\n        [left, right] = this.getChildren(cursor);\n        cursor = index > left ? right : left;\n        continue;\n      }\n    } // calculate the summit hash climbing up again\n\n\n    let node;\n\n    while (height < path.length) {\n      // move cursor\n      cursor = path[height];\n\n      if (height === 0) {\n        // cusor is on the leaf\n        node = this.hashLeaf(cursor, this.hashFn(value));\n      } else if (cursor - 1 === path[height - 1]) {\n        // cursor is on a parent and a siblings is on the left\n        node = this.hashBranch(cursor, siblings[height - 1], node);\n      } else {\n        // cursor is on a parent and a siblings is on the right\n        node = this.hashBranch(cursor, node, siblings[height - 1]);\n      } // climb up\n\n\n      height++;\n    } // computed hash value of the summit should equal to the target peak hash\n\n\n    if (!node.equals(targetPeak)) {\n      throw new Error('hashed peak is invalid');\n    }\n\n    return true;\n  }\n\n  peaksToPeakMap(width, peaks) {\n    const peakMap = {};\n    let bitIndex = 0;\n    let peakRef = 0;\n    let count = peaks.length;\n\n    for (let height = 1; height <= 32; height++) {\n      // index starts from the right most bit\n      bitIndex = 32 - height;\n      peakRef = 1 << height - 1;\n\n      if ((width & peakRef) !== 0) {\n        peakMap[bitIndex] = peaks[--count];\n      } else {\n        peakMap[bitIndex] = 0;\n      }\n    }\n\n    if (count !== 0) {\n      throw new Error('invalid number of peaks');\n    }\n\n    return peakMap;\n  }\n\n  peakMapToPeaks(width, peakMap) {\n    const arrLength = this.numOfPeaks(width);\n    const peaks = new Array(arrLength);\n    let count = 0;\n\n    for (let i = 0; i < 32; i++) {\n      if (peakMap[i] !== 0) {\n        peaks[count++] = peakMap[i];\n      }\n    }\n\n    if (count !== arrLength) {\n      throw new Error('invalid number of peaks');\n    }\n\n    return peaks;\n  }\n\n  peakUpdate(width, prevPeakMap, itemHash) {\n    const nextPeakMap = {};\n    const newWidth = width + 1;\n    let cursorIndex = this.getLeafIndex(newWidth);\n    let cursorNode = this.hashLeaf(cursorIndex, itemHash);\n    let bitIndex = 0;\n    let peakRef = 0;\n    let prevPeakExist = false;\n    let nextPeakExist = false;\n    let obtained = false;\n\n    for (let height = 1; height <= 32; height++) {\n      // index starts from the right most bit\n      bitIndex = 32 - height;\n\n      if (obtained) {\n        nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n      } else {\n        peakRef = 1 << height - 1;\n        prevPeakExist = (width & peakRef) !== 0;\n        nextPeakExist = (newWidth & peakRef) !== 0; // get new cursor node with hashing the peak and the current cursor\n\n        cursorIndex++;\n\n        if (prevPeakExist) {\n          cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);\n        } // if new peak exists for the bit index\n\n\n        if (nextPeakExist) {\n          // if prev peak exists for the bit index\n          if (prevPeakExist) {\n            nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n          } else {\n            nextPeakMap[bitIndex] = cursorNode;\n          }\n\n          obtained = true;\n        } else {\n          nextPeakMap[bitIndex] = 0;\n        }\n      }\n    }\n\n    return nextPeakMap;\n  }\n\n  rollUp(root, width, peaks, itemHashes) {\n    // check the root equals the peak bagging hash\n    if (!root.equals(this.peakBagging(width, peaks))) {\n      throw new Error('invalid root hash from the peaks');\n    }\n\n    let tmpWidth = width;\n    let tmpPeakMap = this.peaksToPeakMap(width, peaks);\n\n    for (let i = 0; i < itemHashes.length; i++) {\n      tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n      tmpWidth++;\n    }\n\n    return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));\n  }\n  /**\n   * @desc It returns the hash value of the node for the index.\n   *      If the hash already exists it simply returns the stored value. On the other hand,\n   *      it computes hashes recursively downward.\n   *      Only appending an item calls this function.\n   */\n\n\n  _getOrCreateNode(index) {\n    if (index > this.size) {\n      throw new Error('out of range');\n    }\n\n    if (!this.hashes[index]) {\n      const [leftIndex, rightIndex] = this.getChildren(index);\n\n      const leftHash = this._getOrCreateNode(leftIndex);\n\n      const rightHash = this._getOrCreateNode(rightIndex);\n\n      this.hashes[index] = this.hashBranch(index, leftHash, rightHash);\n    }\n\n    return this.hashes[index];\n  }\n\n}\n\nexports.MerkleMountainRange = MerkleMountainRange;\nexports.default = MerkleMountainRange;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","MerkleMountainRange","buffer_1","require","sha256_1","Base_1","default","constructor","hashFn","leaves","hashLeafFn","peakBaggingFn","hashBranchFn","root","Buffer","alloc","size","width","hashes","data","map","bufferify","bufferifyFn","leaf","append","dataHash","dataHashHex","bufferToHex","hashLeaf","peakIndexes","getPeakIndexes","getSize","peaks","i","length","_getOrCreateNode","peakBagging","index","concat","hashBranch","left","right","getPeaks","getLeafIndex","numPeaks","numOfPeaks","count","Error","bits","num","getRoot","getHexRoot","getNode","mountainHeight","height","heightAt","reducedIndex","peakIndex","isLeaf","getChildren","getMerkleProof","cursor","siblings","verify","equals","targetPeak","path","Array","node","peaksToPeakMap","peakMap","bitIndex","peakRef","peakMapToPeaks","arrLength","peakUpdate","prevPeakMap","itemHash","nextPeakMap","newWidth","cursorIndex","cursorNode","prevPeakExist","nextPeakExist","obtained","rollUp","itemHashes","tmpWidth","tmpPeakMap","leftIndex","rightIndex","leftHash","rightHash"],"sources":["/Users/yabuch/Desktop/オムニMMMS/shigo-gene-main/shigo_gene_minting_dapp/node_modules/merkletreejs/dist/MerkleMountainRange.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MerkleMountainRange = void 0;\nconst buffer_1 = require(\"buffer\");\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nconst Base_1 = __importDefault(require(\"./Base\"));\n// @credit: https://github.com/wanseob/solidity-mmr\n/**\n * @desc The index of this MMR implementation starts from 1 not 0.\n */\nclass MerkleMountainRange extends Base_1.default {\n    constructor(hashFn = sha256_1.default, leaves = [], hashLeafFn, peakBaggingFn, hashBranchFn) {\n        super();\n        this.root = buffer_1.Buffer.alloc(0);\n        this.size = 0;\n        this.width = 0;\n        this.hashes = {};\n        this.data = {};\n        leaves = leaves.map(this.bufferify);\n        this.hashFn = this.bufferifyFn(hashFn);\n        this.hashLeafFn = hashLeafFn;\n        this.peakBaggingFn = peakBaggingFn;\n        this.hashBranchFn = hashBranchFn;\n        for (const leaf of leaves) {\n            this.append(leaf);\n        }\n    }\n    /**\n     * @desc This only stores the hashed value of the leaf.\n     * If you need to retrieve the detail data later, use a map to store them.\n     */\n    append(data) {\n        data = this.bufferify(data);\n        const dataHash = this.hashFn(data);\n        const dataHashHex = this.bufferToHex(dataHash);\n        if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {\n            this.data[dataHashHex] = data;\n        }\n        const leaf = this.hashLeaf(this.size + 1, dataHash);\n        this.hashes[this.size + 1] = leaf;\n        this.width += 1;\n        // find peaks for enlarged tree\n        const peakIndexes = this.getPeakIndexes(this.width);\n        // the right most peak's value is the new size of the updated tree\n        this.size = this.getSize(this.width);\n        // starting from the left-most peak, get all peak hashes\n        const peaks = [];\n        for (let i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = this._getOrCreateNode(peakIndexes[i]);\n        }\n        // update the tree root hash\n        this.root = this.peakBagging(this.width, peaks);\n    }\n    /**\n     * @desc It returns the hash of a leaf node with hash(M | DATA )\n     *       M is the index of the node.\n     */\n    hashLeaf(index, dataHash) {\n        dataHash = this.bufferify(dataHash);\n        if (this.hashLeafFn) {\n            return this.bufferify(this.hashLeafFn(index, dataHash));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), dataHash]));\n    }\n    /**\n     * @desc It returns the hash a parent node with hash(M | Left child | Right child)\n     *       M is the index of the node.\n     */\n    hashBranch(index, left, right) {\n        if (this.hashBranchFn) {\n            return this.bufferify(this.hashBranchFn(index, left, right));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));\n    }\n    getPeaks() {\n        const peakIndexes = this.getPeakIndexes(this.width);\n        const peaks = [];\n        for (let i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = this.hashes[peakIndexes[i]];\n        }\n        return peaks;\n    }\n    getLeafIndex(width) {\n        if (width % 2 === 1) {\n            return this.getSize(width);\n        }\n        return this.getSize(width - 1) + 1;\n    }\n    /**\n     * @desc It returns all peaks of the smallest merkle mountain range tree which includes\n     *       the given index(size).\n     */\n    getPeakIndexes(width) {\n        const numPeaks = this.numOfPeaks(width);\n        const peakIndexes = [];\n        let count = 0;\n        let size = 0;\n        for (let i = 255; i > 0; i--) {\n            if ((width & (1 << (i - 1))) !== 0) {\n                // peak exists\n                size = size + (1 << i) - 1;\n                peakIndexes[count++] = size;\n                if (peakIndexes.length >= numPeaks) {\n                    break;\n                }\n            }\n        }\n        if (count !== peakIndexes.length) {\n            throw new Error('invalid bit calculation');\n        }\n        return peakIndexes;\n    }\n    numOfPeaks(width) {\n        let bits = width;\n        let num = 0;\n        while (bits > 0) {\n            if (bits % 2 === 1) {\n                num++;\n            }\n            bits = bits >> 1;\n        }\n        return num;\n    }\n    peakBagging(width, peaks) {\n        const size = this.getSize(width);\n        if (this.numOfPeaks(width) !== peaks.length) {\n            throw new Error('received invalid number of peaks');\n        }\n        if (width === 0 && !peaks.length) {\n            return buffer_1.Buffer.alloc(0);\n        }\n        if (this.peakBaggingFn) {\n            return this.bufferify(this.peakBaggingFn(size, peaks));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(size), ...peaks.map(this.bufferify)]));\n    }\n    /**\n     * @desc It returns the size of the tree.\n     */\n    getSize(width) {\n        return (width << 1) - this.numOfPeaks(width);\n    }\n    /**\n     * @desc It returns the root value of the tree.\n     */\n    getRoot() {\n        return this.root;\n    }\n    getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.\n     */\n    getNode(index) {\n        return this.hashes[index];\n    }\n    /**\n     * @desc It returns the height of the highest peak.\n     */\n    mountainHeight(size) {\n        let height = 1;\n        while (1 << height <= size + height) {\n            height++;\n        }\n        return height - 1;\n    }\n    /**\n     * @desc It returns the height of the index.\n     */\n    heightAt(index) {\n        let reducedIndex = index;\n        let peakIndex = 0;\n        let height = 0;\n        // if an index has a left mountain then subtract the mountain\n        while (reducedIndex > peakIndex) {\n            reducedIndex -= (1 << height) - 1;\n            height = this.mountainHeight(reducedIndex);\n            peakIndex = (1 << height) - 1;\n        }\n        // index is on the right slope\n        return height - (peakIndex - reducedIndex);\n    }\n    /**\n     * @desc It returns whether the index is the leaf node or not\n     */\n    isLeaf(index) {\n        return this.heightAt(index) === 1;\n    }\n    /**\n     * @desc It returns the children when it is a parent node.\n     */\n    getChildren(index) {\n        const left = index - (1 << (this.heightAt(index) - 1));\n        const right = index - 1;\n        if (left === right) {\n            throw new Error('not a parent');\n        }\n        return [left, right];\n    }\n    /**\n     * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.\n     */\n    getMerkleProof(index) {\n        if (index > this.size) {\n            throw new Error('out of range');\n        }\n        if (!this.isLeaf(index)) {\n            throw new Error('not a leaf');\n        }\n        const root = this.root;\n        const width = this.width;\n        // find all peaks for bagging\n        const peaks = this.getPeakIndexes(this.width);\n        const peakBagging = [];\n        let cursor = 0;\n        for (let i = 0; i < peaks.length; i++) {\n            // collect the hash of all peaks\n            peakBagging[i] = this.hashes[peaks[i]];\n            // find the peak which includes the target index\n            if (peaks[i] >= index && cursor === 0) {\n                cursor = peaks[i];\n            }\n        }\n        let left = 0;\n        let right = 0;\n        // get hashes of the siblings in the mountain which the index belgons to.\n        // it moves the cursor from the summit of the mountain down to the target index\n        let height = this.heightAt(cursor);\n        const siblings = [];\n        while (cursor !== index) {\n            height--;\n            ([left, right] = this.getChildren(cursor));\n            // move the cursor down to the left size or right size\n            cursor = index <= left ? left : right;\n            // remaining node is the sibling\n            siblings[height - 1] = this.hashes[index <= left ? right : left];\n        }\n        return {\n            root,\n            width,\n            peakBagging,\n            siblings\n        };\n    }\n    /**\n     * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n     */\n    verify(root, width, index, value, peaks, siblings) {\n        value = this.bufferify(value);\n        const size = this.getSize(width);\n        if (size < index) {\n            throw new Error('index is out of range');\n        }\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error('invalid root hash from the peaks');\n        }\n        // find the mountain where the target index belongs to\n        let cursor = 0;\n        let targetPeak;\n        const peakIndexes = this.getPeakIndexes(width);\n        for (let i = 0; i < peakIndexes.length; i++) {\n            if (peakIndexes[i] >= index) {\n                targetPeak = peaks[i];\n                cursor = peakIndexes[i];\n                break;\n            }\n        }\n        if (!targetPeak) {\n            throw new Error('target not found');\n        }\n        // find the path climbing down\n        let height = siblings.length + 1;\n        const path = new Array(height);\n        let left = 0;\n        let right = 0;\n        while (height > 0) {\n            // record the current cursor and climb down\n            path[--height] = cursor;\n            if (cursor === index) {\n                // on the leaf node. Stop climbing down\n                break;\n            }\n            else {\n                // on the parent node. Go left or right\n                ([left, right] = this.getChildren(cursor));\n                cursor = index > left ? right : left;\n                continue;\n            }\n        }\n        // calculate the summit hash climbing up again\n        let node;\n        while (height < path.length) {\n            // move cursor\n            cursor = path[height];\n            if (height === 0) {\n                // cusor is on the leaf\n                node = this.hashLeaf(cursor, this.hashFn(value));\n            }\n            else if (cursor - 1 === path[height - 1]) {\n                // cursor is on a parent and a siblings is on the left\n                node = this.hashBranch(cursor, siblings[height - 1], node);\n            }\n            else {\n                // cursor is on a parent and a siblings is on the right\n                node = this.hashBranch(cursor, node, siblings[height - 1]);\n            }\n            // climb up\n            height++;\n        }\n        // computed hash value of the summit should equal to the target peak hash\n        if (!node.equals(targetPeak)) {\n            throw new Error('hashed peak is invalid');\n        }\n        return true;\n    }\n    peaksToPeakMap(width, peaks) {\n        const peakMap = {};\n        let bitIndex = 0;\n        let peakRef = 0;\n        let count = peaks.length;\n        for (let height = 1; height <= 32; height++) {\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            peakRef = 1 << (height - 1);\n            if ((width & peakRef) !== 0) {\n                peakMap[bitIndex] = peaks[--count];\n            }\n            else {\n                peakMap[bitIndex] = 0;\n            }\n        }\n        if (count !== 0) {\n            throw new Error('invalid number of peaks');\n        }\n        return peakMap;\n    }\n    peakMapToPeaks(width, peakMap) {\n        const arrLength = this.numOfPeaks(width);\n        const peaks = new Array(arrLength);\n        let count = 0;\n        for (let i = 0; i < 32; i++) {\n            if (peakMap[i] !== 0) {\n                peaks[count++] = peakMap[i];\n            }\n        }\n        if (count !== arrLength) {\n            throw new Error('invalid number of peaks');\n        }\n        return peaks;\n    }\n    peakUpdate(width, prevPeakMap, itemHash) {\n        const nextPeakMap = {};\n        const newWidth = width + 1;\n        let cursorIndex = this.getLeafIndex(newWidth);\n        let cursorNode = this.hashLeaf(cursorIndex, itemHash);\n        let bitIndex = 0;\n        let peakRef = 0;\n        let prevPeakExist = false;\n        let nextPeakExist = false;\n        let obtained = false;\n        for (let height = 1; height <= 32; height++) {\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            if (obtained) {\n                nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n            }\n            else {\n                peakRef = 1 << (height - 1);\n                prevPeakExist = (width & peakRef) !== 0;\n                nextPeakExist = (newWidth & peakRef) !== 0;\n                // get new cursor node with hashing the peak and the current cursor\n                cursorIndex++;\n                if (prevPeakExist) {\n                    cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);\n                }\n                // if new peak exists for the bit index\n                if (nextPeakExist) {\n                    // if prev peak exists for the bit index\n                    if (prevPeakExist) {\n                        nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n                    }\n                    else {\n                        nextPeakMap[bitIndex] = cursorNode;\n                    }\n                    obtained = true;\n                }\n                else {\n                    nextPeakMap[bitIndex] = 0;\n                }\n            }\n        }\n        return nextPeakMap;\n    }\n    rollUp(root, width, peaks, itemHashes) {\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error('invalid root hash from the peaks');\n        }\n        let tmpWidth = width;\n        let tmpPeakMap = this.peaksToPeakMap(width, peaks);\n        for (let i = 0; i < itemHashes.length; i++) {\n            tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n            tmpWidth++;\n        }\n        return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));\n    }\n    /**\n     * @desc It returns the hash value of the node for the index.\n     *      If the hash already exists it simply returns the stored value. On the other hand,\n     *      it computes hashes recursively downward.\n     *      Only appending an item calls this function.\n     */\n    _getOrCreateNode(index) {\n        if (index > this.size) {\n            throw new Error('out of range');\n        }\n        if (!this.hashes[index]) {\n            const [leftIndex, rightIndex] = this.getChildren(index);\n            const leftHash = this._getOrCreateNode(leftIndex);\n            const rightHash = this._getOrCreateNode(rightIndex);\n            this.hashes[index] = this.hashBranch(index, leftHash, rightHash);\n        }\n        return this.hashes[index];\n    }\n}\nexports.MerkleMountainRange = MerkleMountainRange;\nexports.default = MerkleMountainRange;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}