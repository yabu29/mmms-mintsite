{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleTree = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst buffer_reverse_1 = __importDefault(require(\"buffer-reverse\"));\n\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\n\nconst treeify_1 = __importDefault(require(\"treeify\"));\n\nconst Base_1 = __importDefault(require(\"./Base\"));\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\n\n\nclass MerkleTree extends Base_1.default {\n  /**\n   * @desc Constructs a Merkle Tree.\n   * All nodes and leaves are stored as Buffers.\n   * Lonely leaf nodes are promoted to the next level up without being hashed again.\n   * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n   * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n   * @param {Object} options - Additional options\n   * @example\n   *```js\n   *const MerkleTree = require('merkletreejs')\n   *const crypto = require('crypto')\n   *\n   *function sha256(data) {\n   *  // returns Buffer\n   *  return crypto.createHash('sha256').update(data).digest()\n   *}\n   *\n   *const leaves = ['a', 'b', 'c'].map(value => keccak(value))\n   *\n   *const tree = new MerkleTree(leaves, sha256)\n   *```\n   */\n  constructor(leaves) {\n    let hashFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256_1.default;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.duplicateOdd = false;\n    this.hashLeaves = false;\n    this.isBitcoinTree = false;\n    this.leaves = [];\n    this.layers = [];\n    this.sortLeaves = false;\n    this.sortPairs = false;\n    this.sort = false;\n    this.fillDefaultHash = null;\n    this.isBitcoinTree = !!options.isBitcoinTree;\n    this.hashLeaves = !!options.hashLeaves;\n    this.sortLeaves = !!options.sortLeaves;\n    this.sortPairs = !!options.sortPairs;\n\n    if (options.fillDefaultHash) {\n      if (typeof options.fillDefaultHash === 'function') {\n        this.fillDefaultHash = options.fillDefaultHash;\n      } else if (buffer_1.Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === 'string') {\n        this.fillDefaultHash = (idx, hashFn) => options.fillDefaultHash;\n      } else {\n        throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n      }\n    }\n\n    this.sort = !!options.sort;\n\n    if (this.sort) {\n      this.sortLeaves = true;\n      this.sortPairs = true;\n    }\n\n    this.duplicateOdd = !!options.duplicateOdd;\n    this.hashFn = this.bufferifyFn(hashFn);\n    this.processLeaves(leaves);\n  }\n\n  processLeaves(leaves) {\n    if (this.hashLeaves) {\n      leaves = leaves.map(this.hashFn);\n    }\n\n    this.leaves = leaves.map(this.bufferify);\n\n    if (this.sortLeaves) {\n      this.leaves = this.leaves.sort(buffer_1.Buffer.compare);\n    }\n\n    if (this.fillDefaultHash) {\n      for (let i = 0; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {\n        if (i >= this.leaves.length) {\n          this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n        }\n      }\n    }\n\n    this.layers = [this.leaves];\n\n    this._createHashes(this.leaves);\n  }\n\n  _createHashes(nodes) {\n    while (nodes.length > 1) {\n      const layerIndex = this.layers.length;\n      this.layers.push([]);\n\n      for (let i = 0; i < nodes.length; i += 2) {\n        if (i + 1 === nodes.length) {\n          if (nodes.length % 2 === 1) {\n            let data = nodes[nodes.length - 1];\n            let hash = data; // is bitcoin tree\n\n            if (this.isBitcoinTree) {\n              // Bitcoin method of duplicating the odd ending nodes\n              data = buffer_1.Buffer.concat([buffer_reverse_1.default(data), buffer_reverse_1.default(data)]);\n              hash = this.hashFn(data);\n              hash = buffer_reverse_1.default(this.hashFn(hash));\n              this.layers[layerIndex].push(hash);\n              continue;\n            } else {\n              if (this.duplicateOdd) {// continue with creating layer\n              } else {\n                // push copy of hash and continue iteration\n                this.layers[layerIndex].push(nodes[i]);\n                continue;\n              }\n            }\n          }\n        }\n\n        const left = nodes[i];\n        const right = i + 1 === nodes.length ? left : nodes[i + 1];\n        let data = null;\n        let combined = null;\n\n        if (this.isBitcoinTree) {\n          combined = [buffer_reverse_1.default(left), buffer_reverse_1.default(right)];\n        } else {\n          combined = [left, right];\n        }\n\n        if (this.sortPairs) {\n          combined.sort(buffer_1.Buffer.compare);\n        }\n\n        data = buffer_1.Buffer.concat(combined);\n        let hash = this.hashFn(data); // double hash if bitcoin tree\n\n        if (this.isBitcoinTree) {\n          hash = buffer_reverse_1.default(this.hashFn(hash));\n        }\n\n        this.layers[layerIndex].push(hash);\n      }\n\n      nodes = this.layers[layerIndex];\n    }\n  }\n  /**\n   * addLeaf\n   * @desc Adds a leaf to the tree and re-calculates layers.\n   * @param {String|Buffer} - Leaf\n   * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.\n   * @example\n   *```js\n   *tree.addLeaf(newLeaf)\n   *```\n   */\n\n\n  addLeaf(leaf) {\n    let shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (shouldHash) {\n      leaf = this.hashFn(leaf);\n    }\n\n    this.processLeaves(this.leaves.concat(leaf));\n  }\n  /**\n   * addLeaves\n   * @desc Adds multiple leaves to the tree and re-calculates layers.\n   * @param {String[]|Buffer[]} - Array of leaves\n   * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.\n   * @example\n   *```js\n   *tree.addLeaves(newLeaves)\n   *```\n   */\n\n\n  addLeaves(leaves) {\n    let shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (shouldHash) {\n      leaves = leaves.map(this.hashFn);\n    }\n\n    this.processLeaves(this.leaves.concat(leaves));\n  }\n  /**\n   * getLeaves\n   * @desc Returns array of leaves of Merkle Tree.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const leaves = tree.getLeaves()\n   *```\n   */\n\n\n  getLeaves(values) {\n    if (Array.isArray(values)) {\n      if (this.hashLeaves) {\n        values = values.map(this.hashFn);\n\n        if (this.sortLeaves) {\n          values = values.sort(buffer_1.Buffer.compare);\n        }\n      }\n\n      return this.leaves.filter(leaf => this._bufferIndexOf(values, leaf) !== -1);\n    }\n\n    return this.leaves;\n  }\n  /**\n   * getLeaf\n   * @desc Returns the leaf at the given index.\n   * @param {Number} - Index number\n   * @return {Buffer}\n   * @example\n   *```js\n   *const leaf = tree.getLeaf(1)\n   *```\n   */\n\n\n  getLeaf(index) {\n    if (index < 0 || index > this.leaves.length - 1) {\n      return buffer_1.Buffer.from([]);\n    }\n\n    return this.leaves[index];\n  }\n  /**\n   * getLeafIndex\n   * @desc Returns the index of the given leaf, or -1 if the leaf is not found.\n   * @param {String|Buffer} - Target leaf\n   * @return {number}\n   * @example\n   *```js\n   *const leaf = Buffer.from('abc')\n   *const index = tree.getLeafIndex(leaf)\n   *```\n   */\n\n\n  getLeafIndex(target) {\n    target = this.bufferify(target);\n    const leaves = this.getLeaves();\n\n    for (let i = 0; i < leaves.length; i++) {\n      const leaf = leaves[i];\n\n      if (leaf.equals(target)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * getLeafCount\n   * @desc Returns the total number of leaves.\n   * @return {number}\n   * @example\n   *```js\n   *const count = tree.getLeafCount()\n   *```\n   */\n\n\n  getLeafCount() {\n    return this.leaves.length;\n  }\n  /**\n   * getHexLeaves\n   * @desc Returns array of leaves of Merkle Tree as hex strings.\n   * @return {String[]}\n   * @example\n   *```js\n   *const leaves = tree.getHexLeaves()\n   *```\n   */\n\n\n  getHexLeaves() {\n    return this.leaves.map(leaf => this.bufferToHex(leaf));\n  }\n  /**\n   * marshalLeaves\n   * @desc Returns array of leaves of Merkle Tree as a JSON string.\n   * @param {String[]|Buffer[]} - Merkle tree leaves\n   * @return {String} - List of leaves as JSON string\n   * @example\n   *```js\n   *const jsonStr = MerkleTree.marshalLeaves(leaves)\n   *```\n   */\n\n\n  static marshalLeaves(leaves) {\n    return JSON.stringify(leaves.map(leaf => MerkleTree.bufferToHex(leaf)), null, 2);\n  }\n  /**\n   * unmarshalLeaves\n   * @desc Returns array of leaves of Merkle Tree as a Buffers.\n   * @param {String|Object} - JSON stringified leaves\n   * @return {Buffer[]} - Unmarshalled list of leaves\n   * @example\n   *```js\n   *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n   *```\n   */\n\n\n  static unmarshalLeaves(jsonStr) {\n    let parsed = null;\n\n    if (typeof jsonStr === 'string') {\n      parsed = JSON.parse(jsonStr);\n    } else if (jsonStr instanceof Object) {\n      parsed = jsonStr;\n    } else {\n      throw new Error('Expected type of string or object');\n    }\n\n    if (!parsed) {\n      return [];\n    }\n\n    if (!Array.isArray(parsed)) {\n      throw new Error('Expected JSON string to be array');\n    }\n\n    return parsed.map(MerkleTree.bufferify);\n  }\n  /**\n   * getLayers\n   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const layers = tree.getLayers()\n   *```\n   */\n\n\n  getLayers() {\n    return this.layers;\n  }\n  /**\n   * getHexLayers\n   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n   * @return {String[]}\n   * @example\n   *```js\n   *const layers = tree.getHexLayers()\n   *```\n   */\n\n\n  getHexLayers() {\n    return this.layers.reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        acc.push(item.map(layer => this.bufferToHex(layer)));\n      } else {\n        acc.push(item);\n      }\n\n      return acc;\n    }, []);\n  }\n  /**\n   * getLayersFlat\n   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n   * @return {Buffer[]}\n   * @example\n   *```js\n   *const layers = tree.getLayersFlat()\n   *```\n   */\n\n\n  getLayersFlat() {\n    const layers = this.layers.reduce((acc, item) => {\n      if (Array.isArray(item)) {\n        acc.unshift(...item);\n      } else {\n        acc.unshift(item);\n      }\n\n      return acc;\n    }, []);\n    layers.unshift(buffer_1.Buffer.from([0]));\n    return layers;\n  }\n  /**\n   * getHexLayersFlat\n   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n   * @return {String[]}\n   * @example\n   *```js\n   *const layers = tree.getHexLayersFlat()\n   *```\n   */\n\n\n  getHexLayersFlat() {\n    return this.getLayersFlat().map(layer => this.bufferToHex(layer));\n  }\n  /**\n   * getLayerCount\n   * @desc Returns the total number of layers.\n   * @return {number}\n   * @example\n   *```js\n   *const count = tree.getLayerCount()\n   *```\n   */\n\n\n  getLayerCount() {\n    return this.getLayers().length;\n  }\n  /**\n   * getRoot\n   * @desc Returns the Merkle root hash as a Buffer.\n   * @return {Buffer}\n   * @example\n   *```js\n   *const root = tree.getRoot()\n   *```\n   */\n\n\n  getRoot() {\n    if (this.layers.length === 0) {\n      return buffer_1.Buffer.from([]);\n    }\n\n    return this.layers[this.layers.length - 1][0] || buffer_1.Buffer.from([]);\n  }\n  /**\n   * getHexRoot\n   * @desc Returns the Merkle root hash as a hex string.\n   * @return {String}\n   * @example\n   *```js\n   *const root = tree.getHexRoot()\n   *```\n   */\n\n\n  getHexRoot() {\n    return this.bufferToHex(this.getRoot());\n  }\n  /**\n   * getProof\n   * @desc Returns the proof for a target leaf.\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {Object[]} - Array of objects containing a position property of type string\n   * with values of 'left' or 'right' and a data property of type Buffer.\n   * @example\n   * ```js\n   *const proof = tree.getProof(leaves[2])\n   *```\n   *\n   * @example\n   *```js\n   *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n   *const tree = new MerkleTree(leaves, keccak)\n   *const proof = tree.getProof(leaves[2], 2)\n   *```\n   */\n\n\n  getProof(leaf, index) {\n    if (typeof leaf === 'undefined') {\n      throw new Error('leaf is required');\n    }\n\n    leaf = this.bufferify(leaf);\n    const proof = [];\n\n    if (!Number.isInteger(index)) {\n      index = -1;\n\n      for (let i = 0; i < this.leaves.length; i++) {\n        if (buffer_1.Buffer.compare(leaf, this.leaves[i]) === 0) {\n          index = i;\n        }\n      }\n    }\n\n    if (index <= -1) {\n      return [];\n    }\n\n    for (let i = 0; i < this.layers.length; i++) {\n      const layer = this.layers[i];\n      const isRightNode = index % 2;\n      const pairIndex = isRightNode ? index - 1 : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1 // Proof Generation for Bitcoin Trees\n      ? index // Proof Generation for Non-Bitcoin Trees\n      : index + 1;\n\n      if (pairIndex < layer.length) {\n        proof.push({\n          position: isRightNode ? 'left' : 'right',\n          data: layer[pairIndex]\n        });\n      } // set index to parent index\n\n\n      index = index / 2 | 0;\n    }\n\n    return proof;\n  }\n  /**\n   * getHexProof\n   * @desc Returns the proof for a target leaf as hex strings.\n   * @param {Buffer} leaf - Target leaf\n   * @param {Number} [index] - Target leaf index in leaves array.\n   * Use if there are leaves containing duplicate data in order to distinguish it.\n   * @return {String[]} - Proof array as hex strings.\n   * @example\n   * ```js\n   *const proof = tree.getHexProof(leaves[2])\n   *```\n   */\n\n\n  getHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(item => this.bufferToHex(item.data));\n  }\n  /**\n  * getPositionalHexProof\n  * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n  * @param {Buffer} leaf - Target leaf\n  * @param {Number} [index] - Target leaf index in leaves array.\n  * Use if there are leaves containing duplicate data in order to distinguish it.\n  * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n  * @example\n  * ```js\n  *const proof = tree.getPositionalHexProof(leaves[2])\n  *```\n  */\n\n\n  getPositionalHexProof(leaf, index) {\n    return this.getProof(leaf, index).map(item => {\n      return [item.position === 'left' ? 0 : 1, this.bufferToHex(item.data)];\n    });\n  }\n  /**\n   * marshalProof\n   * @desc Returns proof array as JSON string.\n   * @param {String[]|Object[]} proof - Merkle tree proof array\n   * @return {String} - Proof array as JSON string.\n   * @example\n   * ```js\n   *const jsonStr = MerkleTree.marshalProof(proof)\n   *```\n   */\n\n\n  static marshalProof(proof) {\n    const json = proof.map(item => {\n      if (typeof item === 'string') {\n        return item;\n      }\n\n      if (buffer_1.Buffer.isBuffer(item)) {\n        return MerkleTree.bufferToHex(item);\n      }\n\n      return {\n        position: item.position,\n        data: MerkleTree.bufferToHex(item.data)\n      };\n    });\n    return JSON.stringify(json, null, 2);\n  }\n  /**\n   * unmarshalProof\n   * @desc Returns the proof for a target leaf as a list of Buffers.\n   * @param {String|Object} - Merkle tree leaves\n   * @return {String|Object} - Marshalled proof\n   * @example\n   * ```js\n   *const proof = MerkleTree.unmarshalProof(jsonStr)\n   *```\n   */\n\n\n  static unmarshalProof(jsonStr) {\n    let parsed = null;\n\n    if (typeof jsonStr === 'string') {\n      parsed = JSON.parse(jsonStr);\n    } else if (jsonStr instanceof Object) {\n      parsed = jsonStr;\n    } else {\n      throw new Error('Expected type of string or object');\n    }\n\n    if (!parsed) {\n      return [];\n    }\n\n    if (!Array.isArray(parsed)) {\n      throw new Error('Expected JSON string to be array');\n    }\n\n    return parsed.map(item => {\n      if (typeof item === 'string') {\n        return MerkleTree.bufferify(item);\n      } else if (item instanceof Object) {\n        return {\n          position: item.position,\n          data: MerkleTree.bufferify(item.data)\n        };\n      } else {\n        throw new Error('Expected item to be of type string or object');\n      }\n    });\n  }\n  /**\n   * getProofIndices\n   * @desc Returns the proof indices for given tree indices.\n   * @param {Number[]} treeIndices - Tree indices\n   * @param {Number} depth - Tree depth; number of layers.\n   * @return {Number[]} - Proof indices\n   * @example\n   * ```js\n   *const proofIndices = tree.getProofIndices([2,5,6], 4)\n   *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n   *```\n   */\n\n\n  getProofIndices(treeIndices, depth) {\n    const leafCount = Math.pow(2, depth);\n    let maximalIndices = new Set();\n\n    for (const index of treeIndices) {\n      let x = leafCount + index;\n\n      while (x > 1) {\n        maximalIndices.add(x ^ 1);\n        x = x / 2 | 0;\n      }\n    }\n\n    const a = treeIndices.map(index => leafCount + index);\n    const b = Array.from(maximalIndices).sort((a, b) => a - b).reverse();\n    maximalIndices = a.concat(b);\n    const redundantIndices = new Set();\n    const proof = [];\n\n    for (let index of maximalIndices) {\n      if (!redundantIndices.has(index)) {\n        proof.push(index);\n\n        while (index > 1) {\n          redundantIndices.add(index);\n          if (!redundantIndices.has(index ^ 1)) break;\n          index = index / 2 | 0;\n        }\n      }\n    }\n\n    return proof.filter(index => {\n      return !treeIndices.includes(index - leafCount);\n    });\n  }\n\n  getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {\n    const depth = Math.ceil(Math.log2(leavesCount));\n    const unevenLayers = [];\n\n    for (let index = 0; index < depth; index++) {\n      const unevenLayer = leavesCount % 2 !== 0;\n\n      if (unevenLayer) {\n        unevenLayers.push({\n          index,\n          leavesCount\n        });\n      }\n\n      leavesCount = Math.ceil(leavesCount / 2);\n    }\n\n    const proofIndices = [];\n    let layerNodes = sortedLeafIndices;\n\n    for (let layerIndex = 0; layerIndex < depth; layerIndex++) {\n      const siblingIndices = layerNodes.map(index => {\n        if (index % 2 === 0) {\n          return index + 1;\n        }\n\n        return index - 1;\n      });\n      let proofNodeIndices = siblingIndices.filter(index => !layerNodes.includes(index));\n      const unevenLayer = unevenLayers.find(_ref => {\n        let {\n          index\n        } = _ref;\n        return index === layerIndex;\n      });\n\n      if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {\n        proofNodeIndices = proofNodeIndices.slice(0, -1);\n      }\n\n      proofIndices.push(proofNodeIndices);\n      layerNodes = [...new Set(layerNodes.map(index => {\n        if (index % 2 === 0) {\n          return index / 2;\n        }\n\n        if (index % 2 === 0) {\n          return (index + 1) / 2;\n        }\n\n        return (index - 1) / 2;\n      }))];\n    }\n\n    return proofIndices;\n  }\n  /**\n   * getMultiProof\n   * @desc Returns the multiproof for given tree indices.\n   * @param {Number[]} indices - Tree indices.\n   * @return {Buffer[]} - Multiproofs\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getMultiProof(indices)\n   *```\n   */\n\n\n  getMultiProof(tree, indices) {\n    if (!indices) {\n      indices = tree;\n      tree = this.getLayersFlat();\n    }\n\n    const isUneven = this.isUnevenTree();\n\n    if (isUneven) {\n      if (indices.every(Number.isInteger)) {\n        return this.getMultiProofForUnevenTree(indices);\n      }\n    }\n\n    if (!indices.every(Number.isInteger)) {\n      let els = indices;\n\n      if (this.sortPairs) {\n        els = els.sort(buffer_1.Buffer.compare);\n      }\n\n      let ids = els.map(el => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n\n      if (!ids.every(idx => idx !== -1)) {\n        throw new Error('Element does not exist in Merkle tree');\n      }\n\n      const hashes = [];\n      const proof = [];\n      let nextIds = [];\n\n      for (let i = 0; i < this.layers.length; i++) {\n        const layer = this.layers[i];\n\n        for (let j = 0; j < ids.length; j++) {\n          const idx = ids[j];\n\n          const pairElement = this._getPairNode(layer, idx);\n\n          hashes.push(layer[idx]);\n\n          if (pairElement) {\n            proof.push(pairElement);\n          }\n\n          nextIds.push(idx / 2 | 0);\n        }\n\n        ids = nextIds.filter((value, i, self) => self.indexOf(value) === i);\n        nextIds = [];\n      }\n\n      return proof.filter(value => !hashes.includes(value));\n    }\n\n    return this.getProofIndices(indices, this._log2(tree.length / 2 | 0)).map(index => tree[index]);\n  }\n\n  getMultiProofForUnevenTree(tree, indices) {\n    if (!indices) {\n      indices = tree;\n      tree = this.getLayers();\n    }\n\n    let proofHashes = [];\n    let currentLayerIndices = indices;\n\n    for (const treeLayer of tree) {\n      const siblings = [];\n\n      for (const index of currentLayerIndices) {\n        if (index % 2 === 0) {\n          const idx = index + 1;\n\n          if (!currentLayerIndices.includes(idx)) {\n            if (treeLayer[idx]) {\n              siblings.push(treeLayer[idx]);\n              continue;\n            }\n          }\n        }\n\n        const idx = index - 1;\n\n        if (!currentLayerIndices.includes(idx)) {\n          if (treeLayer[idx]) {\n            siblings.push(treeLayer[idx]);\n            continue;\n          }\n        }\n      }\n\n      proofHashes = proofHashes.concat(siblings);\n      const uniqueIndices = new Set();\n\n      for (const index of currentLayerIndices) {\n        if (index % 2 === 0) {\n          uniqueIndices.add(index / 2);\n          continue;\n        }\n\n        if (index % 2 === 0) {\n          uniqueIndices.add((index + 1) / 2);\n          continue;\n        }\n\n        uniqueIndices.add((index - 1) / 2);\n      }\n\n      currentLayerIndices = Array.from(uniqueIndices);\n    }\n\n    return proofHashes;\n  }\n  /**\n   * getHexMultiProof\n   * @desc Returns the multiproof for given tree indices as hex strings.\n   * @param {Number[]} indices - Tree indices.\n   * @return {String[]} - Multiproofs as hex strings.\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getHexMultiProof(indices)\n   *```\n   */\n\n\n  getHexMultiProof(tree, indices) {\n    return this.getMultiProof(tree, indices).map(x => this.bufferToHex(x));\n  }\n  /**\n   * getProofFlags\n   * @desc Returns list of booleans where proofs should be used instead of hashing.\n   * Proof flags are used in the Solidity multiproof verifiers.\n   * @param {Number[]|Buffer[]} leaves\n   * @param {Buffer[]} proofs\n   * @return {Boolean[]} - Boolean flags\n   * @example\n   * ```js\n   *const indices = [2, 5, 6]\n   *const proof = tree.getMultiProof(indices)\n   *const proofFlags = tree.getProofFlags(leaves, proof)\n   *```\n   */\n\n\n  getProofFlags(leaves, proofs) {\n    if (!Array.isArray(leaves) || leaves.length <= 0) {\n      throw new Error('Invalid Inputs!');\n    }\n\n    let ids;\n\n    if (leaves.every(Number.isInteger)) {\n      ids = leaves.sort((a, b) => a === b ? 0 : a > b ? 1 : -1); // Indices where passed\n    } else {\n      ids = leaves.map(el => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n    }\n\n    if (!ids.every(idx => idx !== -1)) {\n      throw new Error('Element does not exist in Merkle tree');\n    }\n\n    const _proofs = proofs.map(item => this.bufferify(item));\n\n    const tested = [];\n    const flags = [];\n\n    for (let index = 0; index < this.layers.length; index++) {\n      const layer = this.layers[index];\n      ids = ids.reduce((ids, idx) => {\n        const skipped = tested.includes(layer[idx]);\n\n        if (!skipped) {\n          const pairElement = this._getPairNode(layer, idx);\n\n          const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n\n          pairElement && flags.push(!proofUsed);\n          tested.push(layer[idx]);\n          tested.push(pairElement);\n        }\n\n        ids.push(idx / 2 | 0);\n        return ids;\n      }, []);\n    }\n\n    return flags;\n  }\n  /**\n   * verify\n   * @desc Returns true if the proof path (array of hashes) can connect the target node\n   * to the Merkle root.\n   * @param {Object[]} proof - Array of proof objects that should connect\n   * target node to Merkle root.\n   * @param {Buffer} targetNode - Target node Buffer\n   * @param {Buffer} root - Merkle root Buffer\n   * @return {Boolean}\n   * @example\n   *```js\n   *const root = tree.getRoot()\n   *const proof = tree.getProof(leaves[2])\n   *const verified = tree.verify(proof, leaves[2], root)\n   *```\n   */\n\n\n  verify(proof, targetNode, root) {\n    let hash = this.bufferify(targetNode);\n    root = this.bufferify(root);\n\n    if (!Array.isArray(proof) || !targetNode || !root) {\n      return false;\n    }\n\n    for (let i = 0; i < proof.length; i++) {\n      const node = proof[i];\n      let data = null;\n      let isLeftNode = null; // case for when proof is hex values only\n\n      if (typeof node === 'string') {\n        data = this.bufferify(node);\n        isLeftNode = true;\n      } else if (Array.isArray(node)) {\n        isLeftNode = node[0] === 0;\n        data = this.bufferify(node[1]);\n      } else if (buffer_1.Buffer.isBuffer(node)) {\n        data = node;\n        isLeftNode = true;\n      } else if (node instanceof Object) {\n        data = this.bufferify(node.data);\n        isLeftNode = node.position === 'left';\n      } else {\n        throw new Error('Expected node to be of type string or object');\n      }\n\n      const buffers = [];\n\n      if (this.isBitcoinTree) {\n        buffers.push(buffer_reverse_1.default(hash));\n        buffers[isLeftNode ? 'unshift' : 'push'](buffer_reverse_1.default(data));\n        hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n        hash = buffer_reverse_1.default(this.hashFn(hash));\n      } else {\n        if (this.sortPairs) {\n          if (buffer_1.Buffer.compare(hash, data) === -1) {\n            buffers.push(hash, data);\n            hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n          } else {\n            buffers.push(data, hash);\n            hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n          }\n        } else {\n          buffers.push(hash);\n          buffers[isLeftNode ? 'unshift' : 'push'](data);\n          hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n        }\n      }\n    }\n\n    return buffer_1.Buffer.compare(hash, root) === 0;\n  }\n  /**\n   * verifyMultiProof\n   * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n   * @param {Buffer} root - Merkle tree root\n   * @param {Number[]} proofIndices - Leave indices for proof\n   * @param {Buffer[]} proofLeaves - Leaf values at indices for proof\n   * @param {Number} leavesCount - Count of original leaves\n   * @param {Buffer[]} proof - Multiproofs given indices\n   * @return {Boolean}\n   * @example\n   *```js\n   *const leaves = tree.getLeaves()\n   *const root = tree.getRoot()\n   *const treeFlat = tree.getLayersFlat()\n   *const leavesCount = leaves.length\n   *const proofIndices = [2, 5, 6]\n   *const proofLeaves = proofIndices.map(i => leaves[i])\n   *const proof = tree.getMultiProof(treeFlat, indices)\n   *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)\n   *```\n   */\n\n\n  verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {\n    const isUneven = this.isUnevenTree();\n\n    if (isUneven) {\n      // TODO: combine these functions and simplify\n      return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);\n    }\n\n    const depth = Math.ceil(Math.log2(leavesCount));\n    root = this.bufferify(root);\n    proofLeaves = proofLeaves.map(leaf => this.bufferify(leaf));\n    proof = proof.map(leaf => this.bufferify(leaf));\n    const tree = {};\n\n    for (const [index, leaf] of this._zip(proofIndices, proofLeaves)) {\n      tree[Math.pow(2, depth) + index] = leaf;\n    }\n\n    for (const [index, proofitem] of this._zip(this.getProofIndices(proofIndices, depth), proof)) {\n      tree[index] = proofitem;\n    }\n\n    let indexqueue = Object.keys(tree).map(value => +value).sort((a, b) => a - b);\n    indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n    let i = 0;\n\n    while (i < indexqueue.length) {\n      const index = indexqueue[i];\n\n      if (index >= 2 && {}.hasOwnProperty.call(tree, index ^ 1)) {\n        let pair = [tree[index - index % 2], tree[index - index % 2 + 1]];\n\n        if (this.sortPairs) {\n          pair = pair.sort(buffer_1.Buffer.compare);\n        }\n\n        const hash = pair[1] ? this.hashFn(buffer_1.Buffer.concat(pair)) : pair[0];\n        tree[index / 2 | 0] = hash;\n        indexqueue.push(index / 2 | 0);\n      }\n\n      i += 1;\n    }\n\n    return !proofIndices.length || {}.hasOwnProperty.call(tree, 1) && tree[1].equals(root);\n  }\n\n  verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {\n    root = this.bufferify(root);\n    leaves = leaves.map(this.bufferify);\n    proofs = proofs.map(this.bufferify);\n    const leavesLen = leaves.length;\n    const totalHashes = proofFlag.length;\n    const hashes = [];\n    let leafPos = 0;\n    let hashPos = 0;\n    let proofPos = 0;\n\n    for (let i = 0; i < totalHashes; i++) {\n      const bufA = proofFlag[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];\n      const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n      const buffers = [bufA, bufB].sort(buffer_1.Buffer.compare);\n      hashes[i] = this.hashFn(buffer_1.Buffer.concat(buffers));\n    }\n\n    return buffer_1.Buffer.compare(hashes[totalHashes - 1], root) === 0;\n  }\n\n  verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {\n    root = this.bufferify(root);\n    leaves = leaves.map(leaf => this.bufferify(leaf));\n    proof = proof.map(leaf => this.bufferify(leaf));\n    const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);\n    return root.equals(computedRoot);\n  }\n  /**\n   * getDepth\n   * @desc Returns the tree depth (number of layers)\n   * @return {Number}\n   * @example\n   *```js\n   *const depth = tree.getDepth()\n   *```\n   */\n\n\n  getDepth() {\n    return this.getLayers().length - 1;\n  }\n  /**\n   * getLayersAsObject\n   * @desc Returns the layers as nested objects instead of an array.\n   * @example\n   *```js\n   *const layersObj = tree.getLayersAsObject()\n   *```\n   */\n\n\n  getLayersAsObject() {\n    const layers = this.getLayers().map(layer => layer.map(value => this.bufferToHex(value, false)));\n    const objs = [];\n\n    for (let i = 0; i < layers.length; i++) {\n      const arr = [];\n\n      for (let j = 0; j < layers[i].length; j++) {\n        const obj = {\n          [layers[i][j]]: null\n        };\n\n        if (objs.length) {\n          obj[layers[i][j]] = {};\n          const a = objs.shift();\n          const akey = Object.keys(a)[0];\n          obj[layers[i][j]][akey] = a[akey];\n\n          if (objs.length) {\n            const b = objs.shift();\n            const bkey = Object.keys(b)[0];\n            obj[layers[i][j]][bkey] = b[bkey];\n          }\n        }\n\n        arr.push(obj);\n      }\n\n      objs.push(...arr);\n    }\n\n    return objs[0];\n  }\n  /**\n   * verify\n   * @desc Returns true if the proof path (array of hashes) can connect the target node\n   * to the Merkle root.\n   * @param {Object[]} proof - Array of proof objects that should connect\n   * target node to Merkle root.\n   * @param {Buffer} targetNode - Target node Buffer\n   * @param {Buffer} root - Merkle root Buffer\n   * @param {Function} hashFunction - Hash function for hashing leaves and nodes\n   * @param {Object} options - Additional options\n   * @return {Boolean}\n   * @example\n   *```js\n   *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)\n   *```\n   */\n\n\n  static verify(proof, targetNode, root) {\n    let hashFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sha256_1.default;\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    const tree = new MerkleTree([], hashFn, options);\n    return tree.verify(proof, targetNode, root);\n  }\n  /**\n   * getMultiProof\n   * @desc Returns the multiproof for given tree indices.\n   * @param {Buffer[]} tree - Tree as a flat array.\n   * @param {Number[]} indices - Tree indices.\n   * @return {Buffer[]} - Multiproofs\n   *\n   *@example\n   * ```js\n   *const flatTree = tree.getLayersFlat()\n   *const indices = [2, 5, 6]\n   *const proof = MerkleTree.getMultiProof(flatTree, indices)\n   *```\n   */\n\n\n  static getMultiProof(tree, indices) {\n    const t = new MerkleTree([]);\n    return t.getMultiProof(tree, indices);\n  }\n  /**\n   * resetTree\n   * @desc Resets the tree by clearing the leaves and layers.\n   * @example\n   *```js\n   *tree.resetTree()\n   *```\n   */\n\n\n  resetTree() {\n    this.leaves = [];\n    this.layers = [];\n  }\n  /**\n   * getPairNode\n   * @desc Returns the node at the index for given layer.\n   * @param {Buffer[]} layer - Tree layer\n   * @param {Number} index - Index at layer.\n   * @return {Buffer} - Node\n   *\n   *@example\n   * ```js\n   *const node = tree.getPairNode(layer, index)\n   *```\n   */\n\n\n  _getPairNode(layer, idx) {\n    const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n\n    if (pairIdx < layer.length) {\n      return layer[pairIdx];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * toTreeString\n   * @desc Returns a visual representation of the merkle tree as a string.\n   * @return {String}\n   * @example\n   *```js\n   *console.log(tree.toTreeString())\n   *```\n   */\n\n\n  _toTreeString() {\n    const obj = this.getLayersAsObject();\n    return treeify_1.default.asTree(obj, true);\n  }\n  /**\n   * toString\n   * @desc Returns a visual representation of the merkle tree as a string.\n   * @example\n   *```js\n   *console.log(tree.toString())\n   *```\n   */\n\n\n  toString() {\n    return this._toTreeString();\n  }\n\n  isUnevenTree(treeLayers) {\n    const depth = (treeLayers === null || treeLayers === void 0 ? void 0 : treeLayers.length) || this.getDepth();\n    return !this.isPowOf2(depth);\n  }\n\n  isPowOf2(v) {\n    return v && !(v & v - 1);\n  }\n\n  calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {\n    const leafTuples = this._zip(leafIndices, leafHashes).sort((_ref2, _ref3) => {\n      let [indexA] = _ref2;\n      let [indexB] = _ref3;\n      return indexA - indexB;\n    });\n\n    const leafTupleIndices = leafTuples.map(_ref4 => {\n      let [index] = _ref4;\n      return index;\n    });\n    const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);\n    let nextSliceStart = 0;\n    const proofTuplesByLayers = [];\n\n    for (let i = 0; i < proofIndices.length; i++) {\n      const indices = proofIndices[i];\n      const sliceStart = nextSliceStart;\n      nextSliceStart += indices.length;\n      proofTuplesByLayers[i] = this._zip(indices, proofHashes.slice(sliceStart, nextSliceStart));\n    }\n\n    const tree = [leafTuples];\n\n    for (let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {\n      const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort((_ref5, _ref6) => {\n        let [indexA] = _ref5;\n        let [indexB] = _ref6;\n        return indexA - indexB;\n      }).map(_ref7 => {\n        let [, hash] = _ref7;\n        return hash;\n      });\n      const s = tree[layerIndex].map(_ref8 => {\n        let [layerIndex] = _ref8;\n        return layerIndex;\n      });\n      const parentIndices = [...new Set(s.map(index => {\n        if (index % 2 === 0) {\n          return index / 2;\n        }\n\n        if (index % 2 === 0) {\n          return (index + 1) / 2;\n        }\n\n        return (index - 1) / 2;\n      }))];\n      const parentLayer = [];\n\n      for (let i = 0; i < parentIndices.length; i++) {\n        const parentNodeTreeIndex = parentIndices[i];\n        const bufA = currentLayer[i * 2];\n        const bufB = currentLayer[i * 2 + 1];\n        const hash = bufB ? this.hashFn(buffer_1.Buffer.concat([bufA, bufB])) : bufA;\n        parentLayer.push([parentNodeTreeIndex, hash]);\n      }\n\n      tree.push(parentLayer);\n    }\n\n    return tree[tree.length - 1][0][1];\n  }\n\n}\n\nexports.MerkleTree = MerkleTree;\n\nif (typeof window !== 'undefined') {\n  ;\n  window.MerkleTree = MerkleTree;\n}\n\nexports.default = MerkleTree;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","MerkleTree","buffer_1","require","buffer_reverse_1","sha256_1","treeify_1","Base_1","default","constructor","leaves","hashFn","options","duplicateOdd","hashLeaves","isBitcoinTree","layers","sortLeaves","sortPairs","sort","fillDefaultHash","Buffer","isBuffer","idx","Error","bufferifyFn","processLeaves","map","bufferify","compare","i","Math","pow","ceil","log2","length","push","_createHashes","nodes","layerIndex","data","hash","concat","left","right","combined","addLeaf","leaf","shouldHash","addLeaves","getLeaves","values","Array","isArray","filter","_bufferIndexOf","getLeaf","index","from","getLeafIndex","target","equals","getLeafCount","getHexLeaves","bufferToHex","marshalLeaves","JSON","stringify","unmarshalLeaves","jsonStr","parsed","parse","getLayers","getHexLayers","reduce","acc","item","layer","getLayersFlat","unshift","getHexLayersFlat","getLayerCount","getRoot","getHexRoot","getProof","proof","Number","isInteger","isRightNode","pairIndex","position","getHexProof","getPositionalHexProof","marshalProof","json","unmarshalProof","getProofIndices","treeIndices","depth","leafCount","maximalIndices","Set","x","add","a","b","reverse","redundantIndices","has","includes","getProofIndicesForUnevenTree","sortedLeafIndices","leavesCount","unevenLayers","unevenLayer","proofIndices","layerNodes","siblingIndices","proofNodeIndices","find","slice","getMultiProof","tree","indices","isUneven","isUnevenTree","every","getMultiProofForUnevenTree","els","ids","el","hashes","nextIds","j","pairElement","_getPairNode","self","indexOf","_log2","proofHashes","currentLayerIndices","treeLayer","siblings","uniqueIndices","getHexMultiProof","getProofFlags","proofs","_proofs","tested","flags","skipped","proofUsed","verify","targetNode","root","node","isLeftNode","buffers","verifyMultiProof","proofLeaves","verifyMultiProofForUnevenTree","_zip","proofitem","indexqueue","keys","hasOwnProperty","call","pair","verifyMultiProofWithFlags","proofFlag","leavesLen","totalHashes","leafPos","hashPos","proofPos","bufA","bufB","computedRoot","calculateRootForUnevenTree","getDepth","getLayersAsObject","objs","arr","obj","shift","akey","bkey","t","resetTree","pairIdx","_toTreeString","asTree","toString","treeLayers","isPowOf2","v","leafIndices","leafHashes","totalLeavesCount","leafTuples","indexA","indexB","leafTupleIndices","nextSliceStart","proofTuplesByLayers","sliceStart","currentLayer","s","parentIndices","parentLayer","parentNodeTreeIndex","window"],"sources":["/Users/yabuch/Desktop/オムニMMMS/shigo-gene-main/shigo_gene_minting_dapp/node_modules/merkletreejs/dist/MerkleTree.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MerkleTree = void 0;\nconst buffer_1 = require(\"buffer\");\nconst buffer_reverse_1 = __importDefault(require(\"buffer-reverse\"));\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nconst treeify_1 = __importDefault(require(\"treeify\"));\nconst Base_1 = __importDefault(require(\"./Base\"));\n/**\n * Class reprensenting a Merkle Tree\n * @namespace MerkleTree\n */\nclass MerkleTree extends Base_1.default {\n    /**\n     * @desc Constructs a Merkle Tree.\n     * All nodes and leaves are stored as Buffers.\n     * Lonely leaf nodes are promoted to the next level up without being hashed again.\n     * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.\n     * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @example\n     *```js\n     *const MerkleTree = require('merkletreejs')\n     *const crypto = require('crypto')\n     *\n     *function sha256(data) {\n     *  // returns Buffer\n     *  return crypto.createHash('sha256').update(data).digest()\n     *}\n     *\n     *const leaves = ['a', 'b', 'c'].map(value => keccak(value))\n     *\n     *const tree = new MerkleTree(leaves, sha256)\n     *```\n     */\n    constructor(leaves, hashFn = sha256_1.default, options = {}) {\n        super();\n        this.duplicateOdd = false;\n        this.hashLeaves = false;\n        this.isBitcoinTree = false;\n        this.leaves = [];\n        this.layers = [];\n        this.sortLeaves = false;\n        this.sortPairs = false;\n        this.sort = false;\n        this.fillDefaultHash = null;\n        this.isBitcoinTree = !!options.isBitcoinTree;\n        this.hashLeaves = !!options.hashLeaves;\n        this.sortLeaves = !!options.sortLeaves;\n        this.sortPairs = !!options.sortPairs;\n        if (options.fillDefaultHash) {\n            if (typeof options.fillDefaultHash === 'function') {\n                this.fillDefaultHash = options.fillDefaultHash;\n            }\n            else if (buffer_1.Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === 'string') {\n                this.fillDefaultHash = (idx, hashFn) => options.fillDefaultHash;\n            }\n            else {\n                throw new Error('method \"fillDefaultHash\" must be a function, Buffer, or string');\n            }\n        }\n        this.sort = !!options.sort;\n        if (this.sort) {\n            this.sortLeaves = true;\n            this.sortPairs = true;\n        }\n        this.duplicateOdd = !!options.duplicateOdd;\n        this.hashFn = this.bufferifyFn(hashFn);\n        this.processLeaves(leaves);\n    }\n    processLeaves(leaves) {\n        if (this.hashLeaves) {\n            leaves = leaves.map(this.hashFn);\n        }\n        this.leaves = leaves.map(this.bufferify);\n        if (this.sortLeaves) {\n            this.leaves = this.leaves.sort(buffer_1.Buffer.compare);\n        }\n        if (this.fillDefaultHash) {\n            for (let i = 0; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++) {\n                if (i >= this.leaves.length) {\n                    this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));\n                }\n            }\n        }\n        this.layers = [this.leaves];\n        this._createHashes(this.leaves);\n    }\n    _createHashes(nodes) {\n        while (nodes.length > 1) {\n            const layerIndex = this.layers.length;\n            this.layers.push([]);\n            for (let i = 0; i < nodes.length; i += 2) {\n                if (i + 1 === nodes.length) {\n                    if (nodes.length % 2 === 1) {\n                        let data = nodes[nodes.length - 1];\n                        let hash = data;\n                        // is bitcoin tree\n                        if (this.isBitcoinTree) {\n                            // Bitcoin method of duplicating the odd ending nodes\n                            data = buffer_1.Buffer.concat([buffer_reverse_1.default(data), buffer_reverse_1.default(data)]);\n                            hash = this.hashFn(data);\n                            hash = buffer_reverse_1.default(this.hashFn(hash));\n                            this.layers[layerIndex].push(hash);\n                            continue;\n                        }\n                        else {\n                            if (this.duplicateOdd) {\n                                // continue with creating layer\n                            }\n                            else {\n                                // push copy of hash and continue iteration\n                                this.layers[layerIndex].push(nodes[i]);\n                                continue;\n                            }\n                        }\n                    }\n                }\n                const left = nodes[i];\n                const right = i + 1 === nodes.length ? left : nodes[i + 1];\n                let data = null;\n                let combined = null;\n                if (this.isBitcoinTree) {\n                    combined = [buffer_reverse_1.default(left), buffer_reverse_1.default(right)];\n                }\n                else {\n                    combined = [left, right];\n                }\n                if (this.sortPairs) {\n                    combined.sort(buffer_1.Buffer.compare);\n                }\n                data = buffer_1.Buffer.concat(combined);\n                let hash = this.hashFn(data);\n                // double hash if bitcoin tree\n                if (this.isBitcoinTree) {\n                    hash = buffer_reverse_1.default(this.hashFn(hash));\n                }\n                this.layers[layerIndex].push(hash);\n            }\n            nodes = this.layers[layerIndex];\n        }\n    }\n    /**\n     * addLeaf\n     * @desc Adds a leaf to the tree and re-calculates layers.\n     * @param {String|Buffer} - Leaf\n     * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaf(newLeaf)\n     *```\n     */\n    addLeaf(leaf, shouldHash = false) {\n        if (shouldHash) {\n            leaf = this.hashFn(leaf);\n        }\n        this.processLeaves(this.leaves.concat(leaf));\n    }\n    /**\n     * addLeaves\n     * @desc Adds multiple leaves to the tree and re-calculates layers.\n     * @param {String[]|Buffer[]} - Array of leaves\n     * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.\n     * @example\n     *```js\n     *tree.addLeaves(newLeaves)\n     *```\n     */\n    addLeaves(leaves, shouldHash = false) {\n        if (shouldHash) {\n            leaves = leaves.map(this.hashFn);\n        }\n        this.processLeaves(this.leaves.concat(leaves));\n    }\n    /**\n     * getLeaves\n     * @desc Returns array of leaves of Merkle Tree.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *```\n     */\n    getLeaves(values) {\n        if (Array.isArray(values)) {\n            if (this.hashLeaves) {\n                values = values.map(this.hashFn);\n                if (this.sortLeaves) {\n                    values = values.sort(buffer_1.Buffer.compare);\n                }\n            }\n            return this.leaves.filter(leaf => this._bufferIndexOf(values, leaf) !== -1);\n        }\n        return this.leaves;\n    }\n    /**\n     * getLeaf\n     * @desc Returns the leaf at the given index.\n     * @param {Number} - Index number\n     * @return {Buffer}\n     * @example\n     *```js\n     *const leaf = tree.getLeaf(1)\n     *```\n     */\n    getLeaf(index) {\n        if (index < 0 || index > this.leaves.length - 1) {\n            return buffer_1.Buffer.from([]);\n        }\n        return this.leaves[index];\n    }\n    /**\n     * getLeafIndex\n     * @desc Returns the index of the given leaf, or -1 if the leaf is not found.\n     * @param {String|Buffer} - Target leaf\n     * @return {number}\n     * @example\n     *```js\n     *const leaf = Buffer.from('abc')\n     *const index = tree.getLeafIndex(leaf)\n     *```\n     */\n    getLeafIndex(target) {\n        target = this.bufferify(target);\n        const leaves = this.getLeaves();\n        for (let i = 0; i < leaves.length; i++) {\n            const leaf = leaves[i];\n            if (leaf.equals(target)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * getLeafCount\n     * @desc Returns the total number of leaves.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLeafCount()\n     *```\n     */\n    getLeafCount() {\n        return this.leaves.length;\n    }\n    /**\n     * getHexLeaves\n     * @desc Returns array of leaves of Merkle Tree as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const leaves = tree.getHexLeaves()\n     *```\n     */\n    getHexLeaves() {\n        return this.leaves.map(leaf => this.bufferToHex(leaf));\n    }\n    /**\n     * marshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a JSON string.\n     * @param {String[]|Buffer[]} - Merkle tree leaves\n     * @return {String} - List of leaves as JSON string\n     * @example\n     *```js\n     *const jsonStr = MerkleTree.marshalLeaves(leaves)\n     *```\n     */\n    static marshalLeaves(leaves) {\n        return JSON.stringify(leaves.map(leaf => MerkleTree.bufferToHex(leaf)), null, 2);\n    }\n    /**\n     * unmarshalLeaves\n     * @desc Returns array of leaves of Merkle Tree as a Buffers.\n     * @param {String|Object} - JSON stringified leaves\n     * @return {Buffer[]} - Unmarshalled list of leaves\n     * @example\n     *```js\n     *const leaves = MerkleTree.unmarshalLeaves(jsonStr)\n     *```\n     */\n    static unmarshalLeaves(jsonStr) {\n        let parsed = null;\n        if (typeof jsonStr === 'string') {\n            parsed = JSON.parse(jsonStr);\n        }\n        else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        }\n        else {\n            throw new Error('Expected type of string or object');\n        }\n        if (!parsed) {\n            return [];\n        }\n        if (!Array.isArray(parsed)) {\n            throw new Error('Expected JSON string to be array');\n        }\n        return parsed.map(MerkleTree.bufferify);\n    }\n    /**\n     * getLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayers()\n     *```\n     */\n    getLayers() {\n        return this.layers;\n    }\n    /**\n     * getHexLayers\n     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayers()\n     *```\n     */\n    getHexLayers() {\n        return this.layers.reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.push(item.map(layer => this.bufferToHex(layer)));\n            }\n            else {\n                acc.push(item);\n            }\n            return acc;\n        }, []);\n    }\n    /**\n     * getLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.\n     * @return {Buffer[]}\n     * @example\n     *```js\n     *const layers = tree.getLayersFlat()\n     *```\n     */\n    getLayersFlat() {\n        const layers = this.layers.reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.unshift(...item);\n            }\n            else {\n                acc.unshift(item);\n            }\n            return acc;\n        }, []);\n        layers.unshift(buffer_1.Buffer.from([0]));\n        return layers;\n    }\n    /**\n     * getHexLayersFlat\n     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.\n     * @return {String[]}\n     * @example\n     *```js\n     *const layers = tree.getHexLayersFlat()\n     *```\n     */\n    getHexLayersFlat() {\n        return this.getLayersFlat().map(layer => this.bufferToHex(layer));\n    }\n    /**\n     * getLayerCount\n     * @desc Returns the total number of layers.\n     * @return {number}\n     * @example\n     *```js\n     *const count = tree.getLayerCount()\n     *```\n     */\n    getLayerCount() {\n        return this.getLayers().length;\n    }\n    /**\n     * getRoot\n     * @desc Returns the Merkle root hash as a Buffer.\n     * @return {Buffer}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *```\n     */\n    getRoot() {\n        if (this.layers.length === 0) {\n            return buffer_1.Buffer.from([]);\n        }\n        return this.layers[this.layers.length - 1][0] || buffer_1.Buffer.from([]);\n    }\n    /**\n     * getHexRoot\n     * @desc Returns the Merkle root hash as a hex string.\n     * @return {String}\n     * @example\n     *```js\n     *const root = tree.getHexRoot()\n     *```\n     */\n    getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * getProof\n     * @desc Returns the proof for a target leaf.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {Object[]} - Array of objects containing a position property of type string\n     * with values of 'left' or 'right' and a data property of type Buffer.\n     * @example\n     * ```js\n     *const proof = tree.getProof(leaves[2])\n     *```\n     *\n     * @example\n     *```js\n     *const leaves = ['a', 'b', 'a'].map(value => keccak(value))\n     *const tree = new MerkleTree(leaves, keccak)\n     *const proof = tree.getProof(leaves[2], 2)\n     *```\n     */\n    getProof(leaf, index) {\n        if (typeof leaf === 'undefined') {\n            throw new Error('leaf is required');\n        }\n        leaf = this.bufferify(leaf);\n        const proof = [];\n        if (!Number.isInteger(index)) {\n            index = -1;\n            for (let i = 0; i < this.leaves.length; i++) {\n                if (buffer_1.Buffer.compare(leaf, this.leaves[i]) === 0) {\n                    index = i;\n                }\n            }\n        }\n        if (index <= -1) {\n            return [];\n        }\n        for (let i = 0; i < this.layers.length; i++) {\n            const layer = this.layers[i];\n            const isRightNode = index % 2;\n            const pairIndex = (isRightNode ? index - 1\n                : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1\n                    // Proof Generation for Bitcoin Trees\n                    ? index\n                    // Proof Generation for Non-Bitcoin Trees\n                    : index + 1);\n            if (pairIndex < layer.length) {\n                proof.push({\n                    position: isRightNode ? 'left' : 'right',\n                    data: layer[pairIndex]\n                });\n            }\n            // set index to parent index\n            index = (index / 2) | 0;\n        }\n        return proof;\n    }\n    /**\n     * getHexProof\n     * @desc Returns the proof for a target leaf as hex strings.\n     * @param {Buffer} leaf - Target leaf\n     * @param {Number} [index] - Target leaf index in leaves array.\n     * Use if there are leaves containing duplicate data in order to distinguish it.\n     * @return {String[]} - Proof array as hex strings.\n     * @example\n     * ```js\n     *const proof = tree.getHexProof(leaves[2])\n     *```\n     */\n    getHexProof(leaf, index) {\n        return this.getProof(leaf, index).map(item => this.bufferToHex(item.data));\n    }\n    /**\n    * getPositionalHexProof\n    * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).\n    * @param {Buffer} leaf - Target leaf\n    * @param {Number} [index] - Target leaf index in leaves array.\n    * Use if there are leaves containing duplicate data in order to distinguish it.\n    * @return {(string | number)[][]} - Proof array as hex strings. position at index 0\n    * @example\n    * ```js\n    *const proof = tree.getPositionalHexProof(leaves[2])\n    *```\n    */\n    getPositionalHexProof(leaf, index) {\n        return this.getProof(leaf, index).map(item => {\n            return [\n                item.position === 'left' ? 0 : 1,\n                this.bufferToHex(item.data)\n            ];\n        });\n    }\n    /**\n     * marshalProof\n     * @desc Returns proof array as JSON string.\n     * @param {String[]|Object[]} proof - Merkle tree proof array\n     * @return {String} - Proof array as JSON string.\n     * @example\n     * ```js\n     *const jsonStr = MerkleTree.marshalProof(proof)\n     *```\n     */\n    static marshalProof(proof) {\n        const json = proof.map(item => {\n            if (typeof item === 'string') {\n                return item;\n            }\n            if (buffer_1.Buffer.isBuffer(item)) {\n                return MerkleTree.bufferToHex(item);\n            }\n            return {\n                position: item.position,\n                data: MerkleTree.bufferToHex(item.data)\n            };\n        });\n        return JSON.stringify(json, null, 2);\n    }\n    /**\n     * unmarshalProof\n     * @desc Returns the proof for a target leaf as a list of Buffers.\n     * @param {String|Object} - Merkle tree leaves\n     * @return {String|Object} - Marshalled proof\n     * @example\n     * ```js\n     *const proof = MerkleTree.unmarshalProof(jsonStr)\n     *```\n     */\n    static unmarshalProof(jsonStr) {\n        let parsed = null;\n        if (typeof jsonStr === 'string') {\n            parsed = JSON.parse(jsonStr);\n        }\n        else if (jsonStr instanceof Object) {\n            parsed = jsonStr;\n        }\n        else {\n            throw new Error('Expected type of string or object');\n        }\n        if (!parsed) {\n            return [];\n        }\n        if (!Array.isArray(parsed)) {\n            throw new Error('Expected JSON string to be array');\n        }\n        return parsed.map(item => {\n            if (typeof item === 'string') {\n                return MerkleTree.bufferify(item);\n            }\n            else if (item instanceof Object) {\n                return {\n                    position: item.position,\n                    data: MerkleTree.bufferify(item.data)\n                };\n            }\n            else {\n                throw new Error('Expected item to be of type string or object');\n            }\n        });\n    }\n    /**\n     * getProofIndices\n     * @desc Returns the proof indices for given tree indices.\n     * @param {Number[]} treeIndices - Tree indices\n     * @param {Number} depth - Tree depth; number of layers.\n     * @return {Number[]} - Proof indices\n     * @example\n     * ```js\n     *const proofIndices = tree.getProofIndices([2,5,6], 4)\n     *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]\n     *```\n     */\n    getProofIndices(treeIndices, depth) {\n        const leafCount = Math.pow(2, depth);\n        let maximalIndices = new Set();\n        for (const index of treeIndices) {\n            let x = leafCount + index;\n            while (x > 1) {\n                maximalIndices.add(x ^ 1);\n                x = (x / 2) | 0;\n            }\n        }\n        const a = treeIndices.map(index => leafCount + index);\n        const b = Array.from(maximalIndices).sort((a, b) => a - b).reverse();\n        maximalIndices = a.concat(b);\n        const redundantIndices = new Set();\n        const proof = [];\n        for (let index of maximalIndices) {\n            if (!redundantIndices.has(index)) {\n                proof.push(index);\n                while (index > 1) {\n                    redundantIndices.add(index);\n                    if (!redundantIndices.has(index ^ 1))\n                        break;\n                    index = (index / 2) | 0;\n                }\n            }\n        }\n        return proof.filter(index => {\n            return !treeIndices.includes(index - leafCount);\n        });\n    }\n    getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {\n        const depth = Math.ceil(Math.log2(leavesCount));\n        const unevenLayers = [];\n        for (let index = 0; index < depth; index++) {\n            const unevenLayer = leavesCount % 2 !== 0;\n            if (unevenLayer) {\n                unevenLayers.push({ index, leavesCount });\n            }\n            leavesCount = Math.ceil(leavesCount / 2);\n        }\n        const proofIndices = [];\n        let layerNodes = sortedLeafIndices;\n        for (let layerIndex = 0; layerIndex < depth; layerIndex++) {\n            const siblingIndices = layerNodes.map((index) => {\n                if (index % 2 === 0) {\n                    return index + 1;\n                }\n                return index - 1;\n            });\n            let proofNodeIndices = siblingIndices.filter((index) => !layerNodes.includes(index));\n            const unevenLayer = unevenLayers.find(({ index }) => index === layerIndex);\n            if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {\n                proofNodeIndices = proofNodeIndices.slice(0, -1);\n            }\n            proofIndices.push(proofNodeIndices);\n            layerNodes = [...new Set(layerNodes.map((index) => {\n                    if (index % 2 === 0) {\n                        return index / 2;\n                    }\n                    if (index % 2 === 0) {\n                        return (index + 1) / 2;\n                    }\n                    return (index - 1) / 2;\n                }))];\n        }\n        return proofIndices;\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *```\n     */\n    getMultiProof(tree, indices) {\n        if (!indices) {\n            indices = tree;\n            tree = this.getLayersFlat();\n        }\n        const isUneven = this.isUnevenTree();\n        if (isUneven) {\n            if (indices.every(Number.isInteger)) {\n                return this.getMultiProofForUnevenTree(indices);\n            }\n        }\n        if (!indices.every(Number.isInteger)) {\n            let els = indices;\n            if (this.sortPairs) {\n                els = els.sort(buffer_1.Buffer.compare);\n            }\n            let ids = els.map((el) => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n            if (!ids.every((idx) => idx !== -1)) {\n                throw new Error('Element does not exist in Merkle tree');\n            }\n            const hashes = [];\n            const proof = [];\n            let nextIds = [];\n            for (let i = 0; i < this.layers.length; i++) {\n                const layer = this.layers[i];\n                for (let j = 0; j < ids.length; j++) {\n                    const idx = ids[j];\n                    const pairElement = this._getPairNode(layer, idx);\n                    hashes.push(layer[idx]);\n                    if (pairElement) {\n                        proof.push(pairElement);\n                    }\n                    nextIds.push((idx / 2) | 0);\n                }\n                ids = nextIds.filter((value, i, self) => self.indexOf(value) === i);\n                nextIds = [];\n            }\n            return proof.filter((value) => !hashes.includes(value));\n        }\n        return this.getProofIndices(indices, this._log2((tree.length / 2) | 0)).map(index => tree[index]);\n    }\n    getMultiProofForUnevenTree(tree, indices) {\n        if (!indices) {\n            indices = tree;\n            tree = this.getLayers();\n        }\n        let proofHashes = [];\n        let currentLayerIndices = indices;\n        for (const treeLayer of tree) {\n            const siblings = [];\n            for (const index of currentLayerIndices) {\n                if (index % 2 === 0) {\n                    const idx = index + 1;\n                    if (!currentLayerIndices.includes(idx)) {\n                        if (treeLayer[idx]) {\n                            siblings.push(treeLayer[idx]);\n                            continue;\n                        }\n                    }\n                }\n                const idx = index - 1;\n                if (!currentLayerIndices.includes(idx)) {\n                    if (treeLayer[idx]) {\n                        siblings.push(treeLayer[idx]);\n                        continue;\n                    }\n                }\n            }\n            proofHashes = proofHashes.concat(siblings);\n            const uniqueIndices = new Set();\n            for (const index of currentLayerIndices) {\n                if (index % 2 === 0) {\n                    uniqueIndices.add(index / 2);\n                    continue;\n                }\n                if (index % 2 === 0) {\n                    uniqueIndices.add((index + 1) / 2);\n                    continue;\n                }\n                uniqueIndices.add((index - 1) / 2);\n            }\n            currentLayerIndices = Array.from(uniqueIndices);\n        }\n        return proofHashes;\n    }\n    /**\n     * getHexMultiProof\n     * @desc Returns the multiproof for given tree indices as hex strings.\n     * @param {Number[]} indices - Tree indices.\n     * @return {String[]} - Multiproofs as hex strings.\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getHexMultiProof(indices)\n     *```\n     */\n    getHexMultiProof(tree, indices) {\n        return this.getMultiProof(tree, indices).map((x) => this.bufferToHex(x));\n    }\n    /**\n     * getProofFlags\n     * @desc Returns list of booleans where proofs should be used instead of hashing.\n     * Proof flags are used in the Solidity multiproof verifiers.\n     * @param {Number[]|Buffer[]} leaves\n     * @param {Buffer[]} proofs\n     * @return {Boolean[]} - Boolean flags\n     * @example\n     * ```js\n     *const indices = [2, 5, 6]\n     *const proof = tree.getMultiProof(indices)\n     *const proofFlags = tree.getProofFlags(leaves, proof)\n     *```\n     */\n    getProofFlags(leaves, proofs) {\n        if (!Array.isArray(leaves) || leaves.length <= 0) {\n            throw new Error('Invalid Inputs!');\n        }\n        let ids;\n        if (leaves.every(Number.isInteger)) {\n            ids = leaves.sort((a, b) => a === b ? 0 : a > b ? 1 : -1); // Indices where passed\n        }\n        else {\n            ids = leaves.map((el) => this._bufferIndexOf(this.leaves, el)).sort((a, b) => a === b ? 0 : a > b ? 1 : -1);\n        }\n        if (!ids.every((idx) => idx !== -1)) {\n            throw new Error('Element does not exist in Merkle tree');\n        }\n        const _proofs = proofs.map(item => this.bufferify(item));\n        const tested = [];\n        const flags = [];\n        for (let index = 0; index < this.layers.length; index++) {\n            const layer = this.layers[index];\n            ids = ids.reduce((ids, idx) => {\n                const skipped = tested.includes(layer[idx]);\n                if (!skipped) {\n                    const pairElement = this._getPairNode(layer, idx);\n                    const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);\n                    pairElement && flags.push(!proofUsed);\n                    tested.push(layer[idx]);\n                    tested.push(pairElement);\n                }\n                ids.push((idx / 2) | 0);\n                return ids;\n            }, []);\n        }\n        return flags;\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @return {Boolean}\n     * @example\n     *```js\n     *const root = tree.getRoot()\n     *const proof = tree.getProof(leaves[2])\n     *const verified = tree.verify(proof, leaves[2], root)\n     *```\n     */\n    verify(proof, targetNode, root) {\n        let hash = this.bufferify(targetNode);\n        root = this.bufferify(root);\n        if (!Array.isArray(proof) ||\n            !targetNode ||\n            !root) {\n            return false;\n        }\n        for (let i = 0; i < proof.length; i++) {\n            const node = proof[i];\n            let data = null;\n            let isLeftNode = null;\n            // case for when proof is hex values only\n            if (typeof node === 'string') {\n                data = this.bufferify(node);\n                isLeftNode = true;\n            }\n            else if (Array.isArray(node)) {\n                isLeftNode = (node[0] === 0);\n                data = this.bufferify(node[1]);\n            }\n            else if (buffer_1.Buffer.isBuffer(node)) {\n                data = node;\n                isLeftNode = true;\n            }\n            else if (node instanceof Object) {\n                data = this.bufferify(node.data);\n                isLeftNode = (node.position === 'left');\n            }\n            else {\n                throw new Error('Expected node to be of type string or object');\n            }\n            const buffers = [];\n            if (this.isBitcoinTree) {\n                buffers.push(buffer_reverse_1.default(hash));\n                buffers[isLeftNode ? 'unshift' : 'push'](buffer_reverse_1.default(data));\n                hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n                hash = buffer_reverse_1.default(this.hashFn(hash));\n            }\n            else {\n                if (this.sortPairs) {\n                    if (buffer_1.Buffer.compare(hash, data) === -1) {\n                        buffers.push(hash, data);\n                        hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n                    }\n                    else {\n                        buffers.push(data, hash);\n                        hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n                    }\n                }\n                else {\n                    buffers.push(hash);\n                    buffers[isLeftNode ? 'unshift' : 'push'](data);\n                    hash = this.hashFn(buffer_1.Buffer.concat(buffers));\n                }\n            }\n        }\n        return buffer_1.Buffer.compare(hash, root) === 0;\n    }\n    /**\n     * verifyMultiProof\n     * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.\n     * @param {Buffer} root - Merkle tree root\n     * @param {Number[]} proofIndices - Leave indices for proof\n     * @param {Buffer[]} proofLeaves - Leaf values at indices for proof\n     * @param {Number} leavesCount - Count of original leaves\n     * @param {Buffer[]} proof - Multiproofs given indices\n     * @return {Boolean}\n     * @example\n     *```js\n     *const leaves = tree.getLeaves()\n     *const root = tree.getRoot()\n     *const treeFlat = tree.getLayersFlat()\n     *const leavesCount = leaves.length\n     *const proofIndices = [2, 5, 6]\n     *const proofLeaves = proofIndices.map(i => leaves[i])\n     *const proof = tree.getMultiProof(treeFlat, indices)\n     *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)\n     *```\n     */\n    verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {\n        const isUneven = this.isUnevenTree();\n        if (isUneven) {\n            // TODO: combine these functions and simplify\n            return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);\n        }\n        const depth = Math.ceil(Math.log2(leavesCount));\n        root = this.bufferify(root);\n        proofLeaves = proofLeaves.map(leaf => this.bufferify(leaf));\n        proof = proof.map(leaf => this.bufferify(leaf));\n        const tree = {};\n        for (const [index, leaf] of this._zip(proofIndices, proofLeaves)) {\n            tree[(Math.pow(2, depth)) + index] = leaf;\n        }\n        for (const [index, proofitem] of this._zip(this.getProofIndices(proofIndices, depth), proof)) {\n            tree[index] = proofitem;\n        }\n        let indexqueue = Object.keys(tree).map(value => +value).sort((a, b) => a - b);\n        indexqueue = indexqueue.slice(0, indexqueue.length - 1);\n        let i = 0;\n        while (i < indexqueue.length) {\n            const index = indexqueue[i];\n            if (index >= 2 && ({}).hasOwnProperty.call(tree, index ^ 1)) {\n                let pair = [tree[index - (index % 2)], tree[index - (index % 2) + 1]];\n                if (this.sortPairs) {\n                    pair = pair.sort(buffer_1.Buffer.compare);\n                }\n                const hash = pair[1] ? this.hashFn(buffer_1.Buffer.concat(pair)) : pair[0];\n                tree[(index / 2) | 0] = hash;\n                indexqueue.push((index / 2) | 0);\n            }\n            i += 1;\n        }\n        return !proofIndices.length || (({}).hasOwnProperty.call(tree, 1) && tree[1].equals(root));\n    }\n    verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {\n        root = this.bufferify(root);\n        leaves = leaves.map(this.bufferify);\n        proofs = proofs.map(this.bufferify);\n        const leavesLen = leaves.length;\n        const totalHashes = proofFlag.length;\n        const hashes = [];\n        let leafPos = 0;\n        let hashPos = 0;\n        let proofPos = 0;\n        for (let i = 0; i < totalHashes; i++) {\n            const bufA = proofFlag[i] ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++]) : proofs[proofPos++];\n            const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            const buffers = [bufA, bufB].sort(buffer_1.Buffer.compare);\n            hashes[i] = this.hashFn(buffer_1.Buffer.concat(buffers));\n        }\n        return buffer_1.Buffer.compare(hashes[totalHashes - 1], root) === 0;\n    }\n    verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {\n        root = this.bufferify(root);\n        leaves = leaves.map(leaf => this.bufferify(leaf));\n        proof = proof.map(leaf => this.bufferify(leaf));\n        const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);\n        return root.equals(computedRoot);\n    }\n    /**\n     * getDepth\n     * @desc Returns the tree depth (number of layers)\n     * @return {Number}\n     * @example\n     *```js\n     *const depth = tree.getDepth()\n     *```\n     */\n    getDepth() {\n        return this.getLayers().length - 1;\n    }\n    /**\n     * getLayersAsObject\n     * @desc Returns the layers as nested objects instead of an array.\n     * @example\n     *```js\n     *const layersObj = tree.getLayersAsObject()\n     *```\n     */\n    getLayersAsObject() {\n        const layers = this.getLayers().map((layer) => layer.map((value) => this.bufferToHex(value, false)));\n        const objs = [];\n        for (let i = 0; i < layers.length; i++) {\n            const arr = [];\n            for (let j = 0; j < layers[i].length; j++) {\n                const obj = { [layers[i][j]]: null };\n                if (objs.length) {\n                    obj[layers[i][j]] = {};\n                    const a = objs.shift();\n                    const akey = Object.keys(a)[0];\n                    obj[layers[i][j]][akey] = a[akey];\n                    if (objs.length) {\n                        const b = objs.shift();\n                        const bkey = Object.keys(b)[0];\n                        obj[layers[i][j]][bkey] = b[bkey];\n                    }\n                }\n                arr.push(obj);\n            }\n            objs.push(...arr);\n        }\n        return objs[0];\n    }\n    /**\n     * verify\n     * @desc Returns true if the proof path (array of hashes) can connect the target node\n     * to the Merkle root.\n     * @param {Object[]} proof - Array of proof objects that should connect\n     * target node to Merkle root.\n     * @param {Buffer} targetNode - Target node Buffer\n     * @param {Buffer} root - Merkle root Buffer\n     * @param {Function} hashFunction - Hash function for hashing leaves and nodes\n     * @param {Object} options - Additional options\n     * @return {Boolean}\n     * @example\n     *```js\n     *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)\n     *```\n     */\n    static verify(proof, targetNode, root, hashFn = sha256_1.default, options = {}) {\n        const tree = new MerkleTree([], hashFn, options);\n        return tree.verify(proof, targetNode, root);\n    }\n    /**\n     * getMultiProof\n     * @desc Returns the multiproof for given tree indices.\n     * @param {Buffer[]} tree - Tree as a flat array.\n     * @param {Number[]} indices - Tree indices.\n     * @return {Buffer[]} - Multiproofs\n     *\n     *@example\n     * ```js\n     *const flatTree = tree.getLayersFlat()\n     *const indices = [2, 5, 6]\n     *const proof = MerkleTree.getMultiProof(flatTree, indices)\n     *```\n     */\n    static getMultiProof(tree, indices) {\n        const t = new MerkleTree([]);\n        return t.getMultiProof(tree, indices);\n    }\n    /**\n     * resetTree\n     * @desc Resets the tree by clearing the leaves and layers.\n     * @example\n     *```js\n     *tree.resetTree()\n     *```\n     */\n    resetTree() {\n        this.leaves = [];\n        this.layers = [];\n    }\n    /**\n     * getPairNode\n     * @desc Returns the node at the index for given layer.\n     * @param {Buffer[]} layer - Tree layer\n     * @param {Number} index - Index at layer.\n     * @return {Buffer} - Node\n     *\n     *@example\n     * ```js\n     *const node = tree.getPairNode(layer, index)\n     *```\n     */\n    _getPairNode(layer, idx) {\n        const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;\n        if (pairIdx < layer.length) {\n            return layer[pairIdx];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * toTreeString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @return {String}\n     * @example\n     *```js\n     *console.log(tree.toTreeString())\n     *```\n     */\n    _toTreeString() {\n        const obj = this.getLayersAsObject();\n        return treeify_1.default.asTree(obj, true);\n    }\n    /**\n     * toString\n     * @desc Returns a visual representation of the merkle tree as a string.\n     * @example\n     *```js\n     *console.log(tree.toString())\n     *```\n     */\n    toString() {\n        return this._toTreeString();\n    }\n    isUnevenTree(treeLayers) {\n        const depth = (treeLayers === null || treeLayers === void 0 ? void 0 : treeLayers.length) || this.getDepth();\n        return !this.isPowOf2(depth);\n    }\n    isPowOf2(v) {\n        return v && !(v & (v - 1));\n    }\n    calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {\n        const leafTuples = this._zip(leafIndices, leafHashes).sort(([indexA], [indexB]) => indexA - indexB);\n        const leafTupleIndices = leafTuples.map(([index]) => index);\n        const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);\n        let nextSliceStart = 0;\n        const proofTuplesByLayers = [];\n        for (let i = 0; i < proofIndices.length; i++) {\n            const indices = proofIndices[i];\n            const sliceStart = nextSliceStart;\n            nextSliceStart += indices.length;\n            proofTuplesByLayers[i] = this._zip(indices, proofHashes.slice(sliceStart, nextSliceStart));\n        }\n        const tree = [leafTuples];\n        for (let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++) {\n            const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort(([indexA], [indexB]) => indexA - indexB)\n                .map(([, hash]) => hash);\n            const s = tree[layerIndex].map(([layerIndex]) => layerIndex);\n            const parentIndices = [...new Set(s.map((index) => {\n                    if (index % 2 === 0) {\n                        return index / 2;\n                    }\n                    if (index % 2 === 0) {\n                        return (index + 1) / 2;\n                    }\n                    return (index - 1) / 2;\n                }))];\n            const parentLayer = [];\n            for (let i = 0; i < parentIndices.length; i++) {\n                const parentNodeTreeIndex = parentIndices[i];\n                const bufA = currentLayer[i * 2];\n                const bufB = currentLayer[i * 2 + 1];\n                const hash = bufB ? this.hashFn(buffer_1.Buffer.concat([bufA, bufB])) : bufA;\n                parentLayer.push([parentNodeTreeIndex, hash]);\n            }\n            tree.push(parentLayer);\n        }\n        return tree[tree.length - 1][0][1];\n    }\n}\nexports.MerkleTree = MerkleTree;\nif (typeof window !== 'undefined') {\n    ;\n    window.MerkleTree = MerkleTree;\n}\nexports.default = MerkleTree;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}